/******************************************************************************
* Copyright (c) 2006 Altera Corporation, San Jose, California, USA.
* All rights reserved. All use of this software and documentation is
* subject to the License Agreement located at the end of this file below.
******************************************************************************/
/******************************************************************************
 * NicheStack TCP/IP stack initialization and Operating System Start in main()
 * for Simple Socket Server (SSS) example – Apenas para decriptografia AES.
 *
 * Este código implementa somente a parte de decriptografia. Ele espera receber via
 * conexão TCP uma mensagem binária com 33 bytes no seguinte formato:
 *   - Bytes 0 a 15: Texto criptografado (ciphertext, 16 bytes / 128 bits)
 *   - Byte 16: Separador, que deve ser o caractere ';' (0x3B)
 *   - Bytes 17 a 32: Chave de decriptografia (16 bytes / 128 bits)
 *
 * O código acumula os 33 bytes, converte os blocos de 16 bytes em 4 palavras de 32 bits,
 * envia os dados para o módulo AES via interface Avalon, aciona a operação e, quando
 * concluída, lê o resultado (plaintext) e o imprime.
 *
 * Ajuste os endereços e o protocolo conforme sua implementação.
 ******************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <io.h>
#include <fcntl.h>

/* MicroC/OS-II definitions */
#include "../simple_socket_bsp/HAL/inc/includes.h"
#include "../simple_socket_bsp/system.h"
#include "dm9000a.h"

/* Simple Socket Server definitions */
#include "simple_socket_server.h"
#include "alt_error_handler.h"

/* Nichestack definitions */
#include "../simple_socket_bsp/iniche/src/h/nios2/ipport.h"
#include "../simple_socket_bsp/iniche/src/h/tcpport.h"
#include "../simple_socket_bsp/iniche/src/h/libport.h"
#include "../simple_socket_bsp/iniche/src/nios2/osport.h"

#include "basic_io.h"
#include "LCD.h"
#include "altera_avalon_pio_regs.h"

/* Definições de endereços */
#define SDRAM_BASE 0x08000000     // Endereço base da SDRAM (se necessário)
#define DEC0_BASE  0x00000000     // Endereço base do módulo de decriptografia AES
                                  // Ajuste conforme seu sistema

/* Tamanho da stack da tarefa */
OS_STK SSSDecryptionTaskStk[TASK_STACKSIZE];

/* Declarações para criação de tarefa com TK_NEWTASK */
TK_OBJECT(to_ssstask);
TK_ENTRY(SSSDecryptionTask);

struct inet_taskinfo ssstask = {
    &to_ssstask,
    "simple socket decryption",
    SSSDecryptionTask,
    4,
    APP_STACK_SIZE,
};

void SSSDecryptionTask(void *task_data)
{
    INT8U error_code;

    /* Inicializa a pilha TCP/IP e espera que esteja pronta */
    alt_iniche_init();
    netmain();
    while (!iniche_net_ready)
        TK_SLEEP(1);

    printf("\nSimple Socket Decryption starting up\n");
    LCD_Init();
    LCD_Show_Text("Aguardando cliente");

    int listenFD, clientFD;
    struct sockaddr_in server_addr, client_addr;
    int addr_len = sizeof(client_addr);
    char buf[2000];

    /* Buffers para armazenar os 16 bytes do texto criptografado e os 16 bytes da chave */
    char text_buffer[64]; // Para os 16 bytes de ciphertext
    char key_buffer[64];  // Para os 16 bytes da chave

    /* Cria o socket para o servidor */
    listenFD = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (listenFD < 0) {
        perror("socket falhou");
        exit(EXIT_FAILURE);
    }
    printf("Socket criado\n");

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(7777);      // Porta desejada
    server_addr.sin_addr.s_addr = INADDR_ANY;  // Aceita conexões de qualquer endereço

    if (bind(listenFD, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("bind falhou");
        close(listenFD);
        exit(EXIT_FAILURE);
    }

    if (listen(listenFD, 5) < 0) {
        perror("listen falhou");
        close(listenFD);
        exit(EXIT_FAILURE);
    }
    printf("Servidor aguardando conexao na porta 7777...\n");
    LCD_Show_Text("Aguardando cliente...");

    clientFD = accept(listenFD, (struct sockaddr *)&client_addr, (int *)&addr_len);
    if (clientFD < 0) {
        perror("accept falhou");
        close(listenFD);
        exit(EXIT_FAILURE);
    }
    printf("Cliente conectado!\n");
    LCD_Show_Text("Cliente conectado");

    /* Variáveis para a conversão para 32 bits */
    unsigned int encrypted_word[4];  // Bloco de 128 bits do ciphertext
    unsigned int key_word[4];        // Bloco de 128 bits da chave
    unsigned int decrypted_word[4];  // Bloco de 128 bits do resultado (plaintext)
    int i, total_received, num_bytes;

    /* Loop para receber dados via TCP */
    while (1) {
        total_received = 0;
        /* Acumula dados até ter exatamente 33 bytes */
        while (total_received < 33) {
            num_bytes = recv(clientFD, buf + total_received, sizeof(buf) - total_received, 0);
            if (num_bytes <= 0) {
                break;
            }
            total_received += num_bytes;
        }
        if (total_received == 0) break;  // Conexão fechada
        if (total_received != 33) {
            printf("Tamanho de mensagem invalido: esperado 33, recebido %d\n", total_received);
            continue;
        }

        /* Verifica o separador: byte 16 deve ser 0x3B (';') */
        if ((unsigned char)buf[16] != 0x3B) {
            printf("Separador invalido: esperado ';' (0x3B) no byte 16, recebido 0x%02X\n", (unsigned char)buf[16]);
            continue;
        }

        printf("Mensagem recebida (hex): ");
        for (i = 0; i < total_received; i++) {
            printf("%02X ", (unsigned char)buf[i]);
        }
        printf("\n");

        /* Extrai os 16 bytes do ciphertext (bytes 0 a 15) */
        memcpy(text_buffer, buf, 16);
        /* Extrai os 16 bytes da chave (bytes 17 a 32) */
        memcpy(key_buffer, buf + 17, 16);

        /* Converte os 16 bytes do ciphertext em 4 palavras de 32 bits */
        for (i = 0; i < 4; i++) {
            encrypted_word[i] = ((unsigned int)(unsigned char)text_buffer[i*4]   << 24) |
                                ((unsigned int)(unsigned char)text_buffer[i*4+1] << 16) |
                                ((unsigned int)(unsigned char)text_buffer[i*4+2] << 8)  |
                                ((unsigned int)(unsigned char)text_buffer[i*4+3]);
        }
        /* Converte os 16 bytes da chave em 4 palavras de 32 bits */
        for (i = 0; i < 4; i++) {
            key_word[i] = ((unsigned int)(unsigned char)key_buffer[i*4]   << 24) |
                          ((unsigned int)(unsigned char)key_buffer[i*4+1] << 16) |
                          ((unsigned int)(unsigned char)key_buffer[i*4+2] << 8)  |
                          ((unsigned int)(unsigned char)key_buffer[i*4+3]);
        }

        /* Escreve o bloco de ciphertext nos registradores do módulo de decriptografia.
         * A ordem é invertida: os 4 words são escritos nos offsets 0, 4, 8 e 12.
         */
        for (i = 0; i < 4; i++) {
            IOWR(DEC0_BASE, 4 * i, encrypted_word[3 - i]);
        }
        /* Escreve o bloco de chave nos registradores a partir do offset 16 */
        for (i = 0; i < 4; i++) {
            IOWR(DEC0_BASE, 4 * i + 16, key_word[3 - i]);
        }

        /* Aciona a operação de decriptografia: escreve 1 no registrador de start (offset 60) */
        IOWR(DEC0_BASE, 60, 1);

        /* Aguarda até que a operação termine: polling no registrador finished (offset 48) */
        while (IORD(DEC0_BASE, 48) != 1) {
            ; // Busy-wait (pode inserir delay se necessário)
        }

        /* Lê o bloco de saída (plaintext) dos registradores (offsets 32, 36, 40 e 44) */
        for (i = 0; i < 4; i++) {
            decrypted_word[i] = IORD(DEC0_BASE, 4 * i + 32);
        }

        /* Exibe o resultado (plaintext) em hexadecimal */
        printf("Texto descriptografado:\n");
        for (i = 0; i < 4; i++) {
            printf("0x%08X ", decrypted_word[i]);
        }
        printf("\n");
    }

    if (num_bytes < 0) {
        perror("recv falhou");
    }

    close(clientFD);
    close(listenFD);

    while (1)
        TK_SLEEP(100);
}

int main (int argc, char* argv[], char* envp[])
{
    INT8U error_code;

    DM9000A_INSTANCE(DM9000A_0, dm9000a_0);
    DM9000A_INIT(DM9000A_0, dm9000a_0);

    OSTimeSet(0);

    error_code = OSTaskCreateExt(SSSDecryptionTask,
                                 NULL,
                                 (void *)&SSSDecryptionTaskStk[TASK_STACKSIZE],
                                 SSS_INITIAL_TASK_PRIORITY,
                                 SSS_INITIAL_TASK_PRIORITY,
                                 SSSDecryptionTaskStk,
                                 TASK_STACKSIZE,
                                 NULL,
                                 0);
    alt_uCOSIIErrorHandler(error_code, 0);

    OSStart();

    while (1)
        TK_SLEEP(100);
    return -1;
}

/******************************************************************************
*                                                                             *
* License Agreement                                                           *
* (restante do license header...)                                             *
******************************************************************************/


 /******************************************************************************
 *                                                                             *
 * License Agreement                                                           *
 *                                                                             *
 * Copyright (c) 2006 Altera Corporation, San Jose, California, USA.           *
 * All rights reserved.                                                        *
 *                                                                             *
 * Permission is hereby granted, free of charge, to any person obtaining a     *
 * copy of this software and associated documentation files (the "Software"),  *
 * to deal in the Software without restriction, including without limitation   *
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,    *
 * and/or sell copies of the Software, and to permit persons to whom the       *
 * Software is furnished, subject to the following conditions:                 *
 *                                                                             *
 * The above copyright notice and this permission notice shall be included in  *
 * all copies or substantial portions of the Software.                         *
 *                                                                             *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  *
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,    *
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER      *
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING     *
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER         *
 * DEALINGS IN THE SOFTWARE.                                                   *
 *                                                                             *
 * This agreement shall be governed in all respects by the laws of the State   *
 * of California and by the laws of the United States of America.              *
 * Altera does not recommend, suggest or require that this reference design    *
 * file be used in conjunction or combination with any other product.          *
 ******************************************************************************/
 
